<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BNB Gravity Giggles V2 üêæ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #121212;
            user-select: none;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        #exit-zone {
            position: absolute;
            top: 0;
            right: 0;
            width: 100px;
            height: 100px;
            z-index: 100;
        }

        .tutorial {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.2);
            font-family: sans-serif;
            font-weight: bold;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: fadeOut 3s forwards 2s;
        }
    </style>
</head>

<body>
    <div class="tutorial">Swipe to Push</div>
    <div id="exit-zone"></div>
    <canvas id="gameCanvas"></canvas>

    <script type="module">
        import { GameEngine, Draw } from './game-utils.js';

        // Verlet Point
        class Point {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.oldx = x; this.oldy = y;
                this.pinned = false;
            }
        }

        // Stick Constraint
        class Stick {
            constructor(p0, p1) {
                this.p0 = p0; this.p1 = p1;
                this.length = Math.hypot(p1.x - p0.x, p1.y - p0.y);
            }
        }

        class GravityGame extends GameEngine {
            constructor() {
                super('gameCanvas');
                this.points = [];
                this.sticks = [];
                this.shapes = []; // Clusters of points/sticks
                this.bounce = 0.5;
                this.gravity = 0.5;
                this.friction = 0.99;

                this.setupLedge();
                this.spawnObjects();
                this.setupExit();

                this.start((dt) => this.update(dt), (ctx) => this.draw(ctx));
            }

            setupExit() {
                let taps = 0, timer;
                const z = document.getElementById('exit-zone');
                const trig = () => {
                    taps++; clearTimeout(timer);
                    timer = setTimeout(() => taps = 0, 600);
                    if (taps >= 3) window.location.href = 'index.html';
                };
                z.addEventListener('touchstart', (e) => { e.preventDefault(); trig(); });
                z.addEventListener('mousedown', trig);
            }

            setupLedge() {
                this.ledge = { x: this.width * 0.1, y: this.height * 0.6, w: this.width * 0.8, h: 20 };
            }

            spawnObjects() {
                // Spawn boxes (4 points + 5 sticks)
                for (let i = 0; i < 3; i++) {
                    this.createBox(this.ledge.x + 100 + i * 150, this.ledge.y - 150, 80, 100);
                }
                // Spawn Balls (just single point with large radius for simplicity in this Engine)
                this.createBall(this.ledge.x + 50, this.ledge.y - 80, 40);
            }

            createBox(x, y, w, h) {
                const p1 = new Point(x, y);
                const p2 = new Point(x + w, y);
                const p3 = new Point(x + w, y + h);
                const p4 = new Point(x, y + h);

                this.points.push(p1, p2, p3, p4);

                const s1 = new Stick(p1, p2);
                const s2 = new Stick(p2, p3);
                const s3 = new Stick(p3, p4);
                const s4 = new Stick(p4, p1);
                const s5 = new Stick(p1, p3); // Cross brace

                this.sticks.push(s1, s2, s3, s4, s5);
                this.shapes.push({ points: [p1, p2, p3, p4], color: '#FFD700', type: 'box' });
            }

            createBall(x, y, r) {
                const p = new Point(x, y);
                p.radius = r;
                this.points.push(p);
                this.shapes.push({ points: [p], color: '#0056b3', type: 'circle', radius: r });
            }

            update(dt) {
                // Physics Steps
                this.updatePoints();
                for (let i = 0; i < 3; i++) { // Iterations for constraint stability
                    this.updateSticks();
                    this.constrainPoints();
                }
                this.handleInput();

                // Respawn Logic
                if (this.points.every(p => p.y > this.height + 100)) {
                    this.reset();
                }
            }

            reset() {
                this.points = []; this.sticks = []; this.shapes = [];
                this.spawnObjects();
            }

            updatePoints() {
                for (const p of this.points) {
                    if (!p.pinned) {
                        const vx = (p.x - p.oldx) * this.friction;
                        const vy = (p.y - p.oldy) * this.friction;
                        p.oldx = p.x;
                        p.oldy = p.y;
                        p.x += vx;
                        p.y += vy;
                        p.y += this.gravity;
                    }
                }
            }

            updateSticks() {
                for (const s of this.sticks) {
                    const dx = s.p1.x - s.p0.x;
                    const dy = s.p1.y - s.p0.y;
                    const dist = Math.hypot(dx, dy);
                    const diff = s.length - dist;
                    const percent = diff / dist / 2;
                    const offsetX = dx * percent;
                    const offsetY = dy * percent;

                    if (!s.p0.pinned) {
                        s.p0.x -= offsetX;
                        s.p0.y -= offsetY;
                    }
                    if (!s.p1.pinned) {
                        s.p1.x += offsetX;
                        s.p1.y += offsetY;
                    }
                }
            }

            constrainPoints() {
                for (const p of this.points) {
                    // Ledge Collision
                    if (p.y >= this.ledge.y && p.oldy <= this.ledge.y &&
                        p.x > this.ledge.x && p.x < this.ledge.x + this.ledge.w) {
                        p.y = this.ledge.y;
                        p.oldy = p.y + (p.y - p.oldy) * this.bounce;
                    }
                    // Ground Collision
                    if (p.y > this.height) {
                        // Make noise if impacting fast
                        if (p.y - p.oldy > 5) this.audio.playZap();
                    }

                    // Walls
                    if (p.x < 0) { p.x = 0; p.oldx = p.x + (p.x - p.oldx) * this.bounce; }
                    if (p.x > this.width) { p.x = this.width; p.oldx = p.x + (p.x - p.oldx) * this.bounce; }
                }
            }

            handleInput() {
                // If user is dragging across the screen, impart force on nearby points
                if (this.input.isDown) {
                    // Simple "Explosion/Wind" force near cursor
                    for (const p of this.points) {
                        const dx = this.input.x - p.x;
                        const dy = this.input.y - p.y;
                        const dist = Math.hypot(dx, dy);

                        if (dist < 100) {
                            // Push away
                            const force = (100 - dist) * 0.2; // Strength
                            const ang = Math.atan2(dy, dx);
                            p.x -= Math.cos(ang) * force;
                            p.y -= Math.sin(ang) * force;
                        }
                    }
                }
            }

            draw(ctx) {
                // BG
                ctx.fillStyle = '#121212';
                ctx.fillRect(0, 0, this.width, this.height);

                // Ledge (2.5D)
                ctx.fillStyle = '#333';
                ctx.fillRect(this.ledge.x + 10, this.ledge.y + 10, this.ledge.w, this.ledge.h);
                ctx.fillStyle = '#222';
                ctx.fillRect(this.ledge.x, this.ledge.y, this.ledge.w, this.ledge.h);

                // Shapes
                for (const s of this.shapes) {
                    ctx.fillStyle = s.color;
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    if (s.type === 'box') {
                        ctx.moveTo(s.points[0].x, s.points[0].y);
                        ctx.lineTo(s.points[1].x, s.points[1].y);
                        ctx.lineTo(s.points[2].x, s.points[2].y);
                        ctx.lineTo(s.points[3].x, s.points[3].y);
                        ctx.closePath();
                    } else {
                        Draw.circle(ctx, s.points[0].x, s.points[0].y, s.radius, s.color);
                    }
                    ctx.fill();
                    ctx.stroke();
                }
            }
        }

        new GravityGame();
    </script>
</body>

</html>