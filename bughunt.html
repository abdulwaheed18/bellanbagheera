<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BNB Fly-Zapper V2 üêæ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #121212;
            user-select: none;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        #exit-zone {
            position: absolute;
            top: 0;
            right: 0;
            width: 100px;
            height: 100px;
            z-index: 100;
        }

        .tutorial {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.2);
            font-family: sans-serif;
            font-weight: bold;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: fadeOut 3s forwards 2s;
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
            }
        }
    </style>
</head>

<body>
    <div class="tutorial">Tap to Catch</div>
    <div id="exit-zone"></div>
    <canvas id="gameCanvas"></canvas>

    <script type="module">
        import { GameEngine, Draw, randomRange } from './game-utils.js';

        class FlyGame extends GameEngine {
            constructor() {
                super('gameCanvas');

                this.fly = {
                    x: this.width / 2, y: this.height / 2,
                    radius: 50,
                    vx: 0, vy: 0,
                    state: 'normal', // normal, freeze, dash
                    timer: 0,
                    angle: 0
                };

                this.particles = [];
                this.shake = 0;
                this.score = 0;

                this.setupExit();
                this.start((dt) => this.update(dt), (ctx) => this.draw(ctx));
            }

            setupExit() {
                let taps = 0;
                let timer;
                const zone = document.getElementById('exit-zone');
                const trigger = () => {
                    taps++;
                    clearTimeout(timer);
                    timer = setTimeout(() => taps = 0, 600);
                    if (taps >= 3) window.location.href = 'index.html';
                };
                zone.addEventListener('touchstart', (e) => { e.preventDefault(); trigger(); });
                zone.addEventListener('mousedown', trigger);
            }

            update(dt) {
                // Screen Shake Decay
                if (this.shake > 0) this.shake -= dt * 30;
                if (this.shake < 0) this.shake = 0;

                this.updateFly(dt);
                this.updateInput();
                this.updateParticles(dt);
            }

            updateInput() {
                // Check simple hit (circle vs point)
                if (this.input.justPressed) {
                    const dist = Math.hypot(this.input.x - this.fly.x, this.input.y - this.fly.y);
                    // Generous hitbox (+50px)
                    if (dist < this.fly.radius + 50) {
                        this.onCatch();
                    }
                }
            }

            onCatch() {
                this.score++;
                this.shake = 20; // SCREEEN SHAKEEE
                this.audio.playPop(); // POP sound

                // Spawn Particles (Juice)
                for (let i = 0; i < 15; i++) {
                    this.particles.push({
                        x: this.fly.x, y: this.fly.y,
                        vx: randomRange(-10, 10), vy: randomRange(-10, 10),
                        life: 1.0,
                        color: Math.random() > 0.5 ? '#FFD700' : '#0056b3'
                    });
                }

                // Respawn
                this.fly.x = randomRange(100, this.width - 100);
                this.fly.y = randomRange(100, this.height - 100);
                this.changeFlyState(true);
            }

            updateFly(dt) {
                const fly = this.fly;
                fly.timer -= dt;

                // State Machine
                if (fly.timer <= 0) {
                    this.changeFlyState();
                }

                // Move
                if (fly.state === 'normal' || fly.state === 'dash') {
                    fly.x += fly.vx * (fly.state === 'dash' ? 3 : 1);
                    fly.y += fly.vy * (fly.state === 'dash' ? 3 : 1);
                } else if (fly.state === 'freeze') {
                    // Jitter
                    fly.x += randomRange(-2, 2);
                    fly.y += randomRange(-2, 2);
                }

                // Bounds (Strict Padding 60px)
                const pad = 60;
                if (fly.x < pad) { fly.x = pad; fly.vx = Math.abs(fly.vx); }
                if (fly.x > this.width - pad) { fly.x = this.width - pad; fly.vx = -Math.abs(fly.vx); }
                if (fly.y < pad) { fly.y = pad; fly.vy = Math.abs(fly.vy); }
                if (fly.y > this.height - pad) { fly.y = this.height - pad; fly.vy = -Math.abs(fly.vy); }

                fly.angle += dt * 10;
            }

            changeFlyState(forceNormal = false) {
                const fly = this.fly;
                if (forceNormal || fly.state === 'dash' || fly.state === 'freeze') {
                    // Go Normal
                    fly.state = 'normal';
                    fly.timer = randomRange(1, 3);
                    const angle = randomRange(0, Math.PI * 2);
                    const speed = randomRange(3, 6);
                    fly.vx = Math.cos(angle) * speed;
                    fly.vy = Math.sin(angle) * speed;
                } else {
                    // Random chance: Freeze or Dash?
                    if (Math.random() > 0.5) {
                        fly.state = 'freeze';
                        fly.timer = 0.5; // Short pause
                    } else {
                        fly.state = 'dash';
                        fly.timer = 0.8;
                        // Dash towards center if too close to edge
                        let targetAngle = randomRange(0, Math.PI * 2);
                        fly.vx = Math.cos(targetAngle) * 6;
                        fly.vy = Math.sin(targetAngle) * 6;
                    }
                }
            }

            updateParticles(dt) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    let p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= dt * 2;
                    if (p.life <= 0) this.particles.splice(i, 1);
                }
            }

            draw(ctx) {
                // Clear & Shake
                ctx.save();
                let dx = randomRange(-this.shake, this.shake);
                let dy = randomRange(-this.shake, this.shake);
                ctx.translate(dx, dy);

                ctx.fillStyle = '#121212';
                ctx.fillRect(-dx, -dy, this.width, this.height);

                // Draw Fly
                Draw.glow(ctx, '#FFD700', 30);

                // Wings
                ctx.save();
                ctx.translate(this.fly.x, this.fly.y);
                const wingScale = Math.sin(this.fly.angle);
                ctx.fillStyle = '#0056b3';
                ctx.beginPath();
                ctx.ellipse(-20, 0, 30, 15 * Math.abs(wingScale) + 10, 0, 0, Math.PI * 2);
                ctx.ellipse(20, 0, 30, 15 * Math.abs(wingScale) + 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Body
                Draw.circle(ctx, this.fly.x, this.fly.y, this.fly.radius, '#FFD700');

                // Eyes
                Draw.resetGlow(ctx);
                ctx.fillStyle = '#000';
                Draw.circle(ctx, this.fly.x - 15, this.fly.y - 10, 8, '#000');
                Draw.circle(ctx, this.fly.x + 15, this.fly.y - 10, 8, '#000');

                // Draw Particles
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    Draw.circle(ctx, p.x, p.y, 5, p.color);
                    ctx.globalAlpha = 1;
                });

                ctx.restore();
            }
        }

        new FlyGame();
    </script>
</body>

</html>